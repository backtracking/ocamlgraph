
(* Proof of Bellman-Ford algorithm *)

theory FSetTake

  use export set.Fset

  function take (s:set 'a) : 'a

  axiom take_def:
    forall x : set 'a. not (is_empty x) ->
    mem (take x) x

end

theory Graph

  use export int.Int
  use export FSetTake

  type vertex
  constant vertices : set vertex
  constant s : vertex
  function succ vertex : set vertex
  function weight vertex vertex : int

  axiom s_in_graph: mem s vertices

  axiom succ1:
    forall x: vertex. mem x vertices ->
    forall y: vertex. mem y (succ x) -> mem y vertices

(*  axiom nonneg:
    forall x y: vertex. weight x y >= 0
*)

  inductive path (v1 v2: vertex) (n: int) =
    | path_empty:
	forall v: vertex. path v v 0
    | path_succ:
        forall v1 v2 v3: vertex, n: int.
        path v1 v2 n -> mem v3 (succ v2) -> path v1 v3 (n + weight v2 v3)

  predicate shortest_path (v1 v2: vertex) (n: int) =
    (path v1 v2 n) /\
    (forall m: int. m < n -> not (path v1 v2 m))

  predicate no_path (v1 v2: vertex) =
    forall n: int. not (path v1 v2 n)

  inductive reachable (v: vertex) (d: int) =
    | reach_empty:
	reachable s 0
    | reach_succ:
        forall v1 v2: vertex, n: int.
	reachable v1 n -> mem v2 (succ v1) -> reachable v2 (n + 1)

end 

theory Distance

  use import int.Int

  type dist = Finite int | Infinite

  function (++) (x: dist) (y: dist) : dist =
    match x with
      | Infinite -> Infinite
      | Finite x ->
	match y with
	  | Infinite -> Infinite
	  | Finite y -> Finite (x + y)
	end
    end

  predicate (<<) (x y: dist) =
    match x with
      | Infinite -> false
      | Finite x ->
	match y with
	  | Infinite -> true
          | Finite y -> x < y
	end
    end

  predicate ge (x y: dist) =
    match x with
      | Infinite -> true
      | Finite x ->
	match y with
	  | Infinite -> false
	  | Finite y -> x >= y
        end
    end

  clone export comparison.MinMax with type t = dist, predicate ge = ge

end

(* a bag is simply a reference containing a finite set *)
module Bag

  use export FSetTake
  use export module ref.Ref

  type bag 'a = ref (set 'a)

  let is_empty (b: bag 'a) =
    {} is_empty !b { result=True <-> is_empty !b }

  (*
  val push (x: 'a) (b: bag 'a) :
    {} unit writes b { !b = add x (old !b) }
  *)

  let pop (b: bag 'a) =
    { not (is_empty !b) }
    let x = take !b in
    b := remove x !b;
    x
    { mem result (old !b) /\ !b = remove result (old !b) }

end

module BellmanFordTermination

  use import int.MinMax
  use import map.Map
  use import module ref.Ref
  use import Graph
  use import Distance
  use module Bag

  type distmap = map vertex dist

  function initialize_single_source (s: vertex) : distmap =
    (const Infinite)[s <- Finite 0]

  let relax (m: ref distmap) (u: vertex) (v: vertex) =
    { }
    let d = !m[u] ++ Finite (weight u v) in
    if d << !m[v] then m := !m[u <- d]
    { }

  exception NegativeCycle (* list vertex *)

  let bellman_ford () =
    { }
    let m = ref (initialize_single_source s) in

    (let i = ref vertices in
     while not (Bag.is_empty i) do
      variant { cardinal !i }
      let x = Bag.pop i in
      let us = ref vertices in
      while not (Bag.is_empty us) do
	variant { cardinal !us }
        let u = Bag.pop us in

	let vs = ref (succ u) in
	while not (Bag.is_empty vs) do
	  variant { cardinal !vs }
	  let v = Bag.pop vs in
	  relax m u v
	done
      done
    done);

    (let us = ref vertices in
    while not (Bag.is_empty us) do
      variant { cardinal !us }
      let u = Bag.pop us in
    
      let vs = ref (succ u) in
      while not (Bag.is_empty vs) do
	variant { cardinal !vs }
        let v = Bag.pop vs in

	if (get !m v) <<
	  ((get !m u) ++ (Finite (weight u v))) then
	  raise NegativeCycle
      done
    done);
    !m
    { } | NegativeCycle -> { }

end

module BellmanFordSoundness

  use import int.MinMax
  use import map.Map
  use import module ref.Ref
  use import Graph
  use import Distance
  use module Bag

  type distmap = map vertex dist

  function initialize_single_source (s: vertex) : distmap =
    (const Infinite)[s <- Finite 0]

  predicate paths (m: distmap) =
    forall v: vertex. mem v vertices ->
    match m[v] with
      | Finite n -> path s v n (* path, not shortest_path *)
      | Infinite -> true
    end 

  let relax (m: ref distmap) (u: vertex) (v: vertex) =
    { mem u vertices /\ mem v vertices /\ mem v (succ u) /\ paths !m }
    let d = !m[u] ++ Finite (weight u v) in
    if d << !m[v] then m := !m[u <- d]
    { paths !m }

  exception NegativeCycle (* list vertex *)

  let bellman_ford () =
    { }
    let m = ref (initialize_single_source s) in
    assert { paths !m };
    (for i = 1 to cardinal vertices - 1 do
      invariant { paths !m }

      let us = ref vertices in
      while not (Bag.is_empty us) do
	invariant { subset !us vertices /\ paths !m }
        variant { cardinal !us }
        let u = Bag.pop us in

	let vs = ref (succ u) in
	while not (Bag.is_empty vs) do
	  invariant { subset !vs (succ u) /\ paths !m }
          variant { cardinal !vs }

	  let v = Bag.pop vs in
	  relax m u v
	done
      done
    done);

    (let us = ref vertices in
    while not (Bag.is_empty us) do
      variant { cardinal !us }
      let u = Bag.pop us in
    
      let vs = ref (succ u) in
      while not (Bag.is_empty vs) do
	variant { cardinal !vs }
        let v = Bag.pop vs in

	if (get !m v) <<
	  ((get !m u) ++ (Finite (weight u v))) then
	  raise NegativeCycle
      done
    done);
    !m
    { paths result }
    | NegativeCycle -> { }

end

(***
module BellmanFord

  use import int.MinMax
  use import map.Map
  use import module ref.Ref
  use import Graph
  use import Distance
  use module Bag

  type distmap = map vertex dist

  function initialize_single_source (s: vertex) : distmap =
    (const Infinite)[s <- Finite 0]

(*
  let relax (m: distmap) (u: vertex) (v: vertex) : distmap =
    { mem u vertices /\ mem v vertices }
    let new_dv = (get m u) ++ (Finite (weight u v)) in
    if new_dv << (get m v) then (set m v new_dv) else m
    { forall x: vertex. (x <> v -> get m x = get result x) }
*)

  function relax (m: distmap) (u: vertex) (v: vertex) : distmap

  axiom relax_def:
    forall u v: vertex. mem u vertices /\ mem v vertices ->
    forall m m1: distmap. m1 = relax m u v ->
    (forall w: vertex. v <> w -> get m w = get m1 w) /\
    (get m1 v = min (get m v) ((get m u) ++ (Finite (weight u v))))

(*  
    let new_dv = add_dist (get !m u) (Finite (weight u v)) in
    if compare_dist (get !m v) new_dv > 0 then
      let _ = set !m v new_dv in ()
*)

  exception NegativeCycle (* list vertex *)

  let rec relax3 (m: distmap) (u: vertex) (vs: set vertex)
      variant { cardinal vs } =
    { mem u vertices /\ subset vs vertices }
    if cardinal vs <> 0 then
      let v = take vs in
      relax3 (relax m u v) u (remove v vs)
    else
      m
    { }

  let rec relax2 (m: distmap) (us: set vertex)
      variant { cardinal us } =
    if cardinal us <> 0 then
      let u = take us in
      relax2 (relax3 m u (succ u)) (remove u us)
    else
      m

  let rec relax1 (m: distmap) (is: set vertex)
      variant { cardinal is } =
    { 0 <= cardinal is <= cardinal vertices (* /\
      (forall v: vertex.
       reachable v ((cardinal vertices) - (cardinal is)) ->
       shortest_path  *) }
    if cardinal is <> 0 then
      let i = take is in
      relax1 (relax2 m vertices) (remove i is)
    else
      m
    { }


(*
  let rec check_ (m: distmap) (u: vertex) (v: vertex) =
    if (get m v) << ((get m u) ++ (Finite (weight u v))) then
      m
    else raise NegativeCycle

  let rec check2 (m: distmap) (u: vertex) (vs: set vertex)
      variant { cardinal vs } =
    if cardinal vs <> 0 then
      let v = take vs in
      check2 (check_ m u v) u (remove v vs)
    else
      m

  let rec check1 (m: distmap) (us: set vertex)
      variant { cardinal us } =
    if cardinal us <> 0 then
      let u = take us in
      check1 (check2 m u (succ u)) (remove u us)
    else
      m
      *)

  let bellman_ford2 () =
    { true }

    let m = relax1 (initialize_single_source s) vertices in
    m
    (* check1 m (vertices) *)

    { (* the returned map contains the shortest distance from s to any
         reachable vertex *)
      forall v: vertex. mem v vertices ->
        match result[v] with
        | Finite n -> shortest_path s v n
        | Infinite -> no_path s v
        end
    }
(*    | NegativeCycle ->
    { (* there is (at least) one negative cycle *)
      exists v: vertex. mem v vertices /\
      exists n: int. n < 0 /\ path v v n  }
*)



end
***)

(*
Local Variables:
compile-command: "why3ide bf.mlw"
End:
*)
